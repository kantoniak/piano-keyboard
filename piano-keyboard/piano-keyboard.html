<style>
piano-keyboard { background: none; }
piano-keyboard:not(:defined) { display: block; width: 6.47em; height: 4em; margin: 1em 0; background: #EEE; }
</style>

<template id="piano-keyboard-template">
<style>
:host { display: flex; flex-direction: column; justify-content: center; align-items: stretch; align-content: stretch; contain: content; margin: 1em 0; background: #EEE; }
:host([hidden]) { display: none; }
</style>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <style>
        [href="#symbol-white-key"] {
          fill: var(--white-key-fill, #FFF);
          stroke: var(--white-key-stroke, none);
          stroke-width: 1;
        }
        [href="#symbol-white-key"].pressed {
          fill: var(--white-key-pressed-fill, #BBB);
        }
        [href="#symbol-black-key"] {
          fill: var(--black-key-fill, #000);
        }
        [href="#symbol-black-key"].pressed {
          fill: var(--black-key-pressed-fill, #666);
        }
        #top {
          fill: var(--top-cover-fill, #222);
        }
    </style>
    <symbol id="symbol-white-key">
        <rect x="0.5" y="-15" rx="1" ry="1" width="15" height="114" fill="inherit" />
    </symbol>
    <symbol id="symbol-black-key">
        <rect x="0" y="-15" rx="1" ry="1" width="8" height="80" fill="inherit" />
    </symbol>
    <rect id="top" x="0" y="0" width="100%" height="3" fill="inherit" />
</svg>
</template>

<script>
(function() {
  // Move style to master document (see https://goo.gl/EGXzpw)
  const style = document.currentScript.ownerDocument.querySelector('style');
  document.head.appendChild(style);
})();
</script>


<script>
class PianoKeyboard extends HTMLElement {

  static get observedAttributes() {
    return ['pressed'];
  }

  get pressed() {
    return this.getAttribute('pressed');
  }

  set pressed(val) {
    if (val) {
      this.setAttribute('pressed', val);
    } else {
      this.removeAttribute('pressed');
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    const hasValue = newValue !== null;
    if (name == 'pressed') {
      this._releaseAllKeys();
      if (hasValue) {
        let newPressed = newValue.split(',').map(e => parseInt(e.trim()));
        newPressed.forEach(k => this._pressKey(k));
      } else {
        this.removeAttribute('pressed');
      }
    }
  }

  _releaseAllKeys() {
    this.drawing
      .querySelectorAll('[href="#symbol-white-key"], [href="#symbol-black-key"]')
      .forEach(e => e.setAttribute('class', ''));
  }

  _pressKey(k) {
    let key = this.drawing.getElementById('key-'+k);
    if (key == null) {
      return;
    }
    key.setAttribute('class', 'pressed');
  }

  static isBlackKey(key) {
    return [0, 2, 5, 7, 10].includes(key % 12);
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });

    this.SVG_XMLNS = "http://www.w3.org/2000/svg";

    const importDoc = document.currentScript.ownerDocument;
    const template = importDoc.getElementById('piano-keyboard-template').content;
    this.shadowRoot.appendChild(template.cloneNode(true));
    this.drawing = this.shadowRoot.querySelector('svg');
    this.topCover = this.drawing.getElementById('top');

    this._render();
  }

  connectedCallback() {
    this._upgradeProperty('pressed');
  }

  _upgradeProperty(prop) {
    if (this.hasOwnProperty(prop)) {
      let value = this[prop];
      delete this[prop];
      this[prop] = value;
    }
  }

  _render() {
    const startKey = 40;
    const endKey = 64;

    console.assert(!PianoKeyboard.isBlackKey(startKey));
    console.assert(!PianoKeyboard.isBlackKey(endKey));

    this._renderWhiteKeys(startKey, endKey);
    this._renderBlackKeys(startKey, endKey);
  }

  _renderWhiteKeys(startKey, endKey) {
    let currentX = 0;
    for (let k = startKey; k <= endKey; k++) {
        if (PianoKeyboard.isBlackKey(k)) {
            continue;
        }
        
        var key = document.createElementNS(this.SVG_XMLNS, 'use');
        key.setAttribute('href', '#symbol-white-key');
        key.setAttribute('x', currentX);
        key.setAttribute('id', 'key-'+k);
        this.drawing.insertBefore(key, this.topCover);
        currentX += 16;
    }

    let width = currentX;
    this.drawing.setAttribute('viewBox', '0 0 ' + width + ' 100');
  }

  _renderBlackKeys(startKey, endKey) {
    const range = (start, end) => { return new Array(end - start).fill().map((d, i) => i + start); }
    const blackKeys = range(startKey, endKey).filter(PianoKeyboard.isBlackKey);
    
    const baseOffset = this._getKeyOffset(startKey);

    blackKeys.forEach((k) => {
        var key = document.createElementNS(this.SVG_XMLNS, 'use');
        key.setAttribute('href', '#symbol-black-key');
        key.setAttribute('x', (this._getKeyOffset(k) - baseOffset) * 16);
        key.setAttribute('id', 'key-'+k);
        this.drawing.insertBefore(key, this.topCover);
    });
  }

  _getKeyOffset(key) {
      const offsets = [0.25, 0.5, 1.3, 2, 2.5, 3.22, 3.5, 4.28, 5, 5, 6.20, 6];
      let offsetForKey = ((key%12)+12)%12;
      return 7 * Math.floor(key/12) + offsets[offsetForKey];
  }

}

window.customElements.define('piano-keyboard', PianoKeyboard);
</script>